# CoreDNS

CoreDNS is a DNS server. It is written in Go. It can be used in a multitude of environments because of its flexibility. 

CoreDNS is licensed under the Apache License Version 2, and completely open source.

___

## Why CoreDNS

CoreDNS can be setting in different kind of systems such as Docker Swarm, Kubernetes, dcOS, Linux, CoreOS and etc. Also is the default name service in kubernetes.

## CoreDNS plugins

___

CoreDNS supports has some plugins to extend it behaivours such as:

1. forward
2. tls
3. health
4. log

All of the plugins above you'll be configure to extend coreDNS funcionality and allow forward requests to an external DNS nameserver and set-up DNS-over-TLS.

### Requirements

___

You must have installed the following tools on your local machine or infrastructure before start.

1. docker swarm cluster
2. docker-compose
3. minikube
4. kdig

### _Instalation_

On mac use the brew formulas to install the tools above.

```shell
brew install minikube knot docker docker-compose
```

### Structure

___

```text
.
├── gen_certs.sh
├── coredns.yaml
├── config
│   ├── k8s
│   │   └── Corefile.yaml
│   └── docker
│       ├── coredns_tls
│       └── coredns_forward
├── certs
│   ├── server-req.pem
│   ├── key.pem
│   ├── cert.pem
│   ├── ca.pem
│   └── ca-key.pem
└── README.md
```

## How to deploy

___

In order to get coreDNS up and running your evironment there are two options based on Docker(AWS Fargate/ECS) or Kubernetes.

### Before start

___

Before you start the deploy process, please make sure you have the certificates in ready to allow the *TLS* communication over a secure tunel.</br>
Use the script _gen_certs.sh_ to generate your certificates</br>

> The script creates non-signed certificates, that means, fake ones.

```shell
bash gen_certs.sh certs
```

### Deploy on Docker environment

___

The easy way to deploy coreDNS on docker is to use the _coredns.yaml file_. That files contains all the steps to bring coreDNS up and running in a few seconds.</br>
Docker swarm supports *replicas set to easly scale-up* coreDNS to support extra workloads.

```shell
docker stack deploy -c coredns.yaml coredns
```

</br>

Checking deployment</br>

```shell
docker stack services coredns
```

Validating coreDNS + TLS

```shell
$ kdig -d @127.0.0.1 n26.com +tls
;; DEBUG: Querying for owner(n26.com.), class(1), type(1), server(127.0.0.1), port(853), protocol(TCP)
;; DEBUG: TLS, received certificate hierarchy:
;; DEBUG:  #1, C=GE,ST=Berlin,L=Berlin,O=N26,OU=SRE,EMAIL=rdgacarvalho@gmail.com
;; DEBUG:      SHA-256 PIN: g5GxFtG7x1z5PFcMh3Cge+I/svBpgE74vUBbjv8cU8U=
;; DEBUG: TLS, skipping certificate PIN check
;; DEBUG: TLS, skipping certificate verification
;; TLS session (TLS1.3)-(ECDHE-X25519)-(RSA-PSS-RSAE-SHA256)-(AES-128-GCM)
;; ->>HEADER<<- opcode: QUERY; status: NOERROR; id: 16028
;; Flags: qr rd ra; QUERY: 1; ANSWER: 1; AUTHORITY: 0; ADDITIONAL: 1

;; EDNS PSEUDOSECTION:
;; Version: 0; flags: ; UDP size: 4096 B; ext-rcode: NOERROR

;; QUESTION SECTION:
;; n26.com.            		IN	A

;; ANSWER SECTION:
n26.com.            	46	IN	A	128.65.211.162

;; Received 59 B
;; Time 2020-09-17 12:42:58 CEST
;; From 127.0.0.1@853(TCP) in 47.5 ms
```

Validating coreDNS + non-TLS

```shell
kdig -d @127.0.0.1 n26.com +notls
;; DEBUG: Querying for owner(n26.com.), class(1), type(1), server(127.0.0.1), port(53), protocol(UDP)
;; ->>HEADER<<- opcode: QUERY; status: NOERROR; id: 19766
;; Flags: qr rd ra; QUERY: 1; ANSWER: 1; AUTHORITY: 0; ADDITIONAL: 0

;; QUESTION SECTION:
;; n26.com.            		IN	A

;; ANSWER SECTION:
n26.com.            	43	IN	A	128.65.211.162

;; Received 48 B
;; Time 2020-09-17 12:44:21 CEST
;; From 127.0.0.1@53(UDP) in 269.9 ms
```

### Deploy on Kubernetes

___

Kubernetes has by default coreDNS as nameserver service to execute *Service Discovery* an so on. Unfortunately, TLS is disable by default in the ConfigMap scope.

#### Corefile

CoreDNS relies on _Corefile_ file, that means, all of the plugins and fuctionalities must be defined in that file.</br>
In Kubernetes is necessary to set-up the keys generated by the _gen_certs.sh_ script as *Secrets*.

#### Setting secrets on Kubernetes

```shell
kubectl create secret generic coredns_ca -n kube-system \
  --from-file=ca.pem
  ```

```shell
kubectl create secret generic coredns_key -n kube-system \
--from-file=key
```

```shell
kubectl create secret generic coredns_cert -n kube-system \
--from-file=cert.pem
```

### Updating CoreDNS ConfigMap

___

Make sure to create a backup before execute this step.

```shell
kubectl --context <cluster-context> apply -f config/k8s/Corefile.yaml -n kube-system --record
```

Validating ConfigMap

```shell
kubectl --context <cluster-context> -n kube-system get cm coredns -oyaml
```

Restarting Pod(s)

```shell
kubectl --context <cluster-context> -n kube-system delete pod -l"k8s-app=kube-dns"
```

Validating Pod(s)

```shell
kubectl --context <cluster-context> -n kube-system logs -l"k8s-app=kube-dns" -f | head
.:53
tls://.:853
[INFO] plugin/reload: Running configuration MD5 = 50399d071aca062ce64470f8fc46cc93
CoreDNS-1.6.7
linux/amd64, go1.13.6, da7f65b
```

### References

___

https://coredns.io/</br>
https://coredns.io/plugins/</br>
https://coredns.io/plugins/forward/</br>
https://coredns.io/plugins/tls/</br>
